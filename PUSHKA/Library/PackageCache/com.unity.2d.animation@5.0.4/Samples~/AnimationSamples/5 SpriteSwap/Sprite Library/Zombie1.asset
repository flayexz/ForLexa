               }
                    else if (z < x)
                    {
                        c.a = z;
                        c.b = x;
                        c.c = y;
                    }

                    cells[i] = c;
                }

                unsafe
                {
                    TessUtils.InsertionSort<TessCell, TessCellCompare>(
                        NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(cells), 0, m_CellCount - 1,
                        new TessCellCompare());
                }

                // Out
                m_Flags = new NativeArray<int>(nc, Allocator.Temp);
                m_Neighbors = new NativeArray<int>(nc * 3, Allocator.Temp);
                m_Constraints = new NativeArray<int>(nc * 3, Allocator.Temp);
                var next = new NativeArray<int>(nc * 3, Allocator.Temp);
                var active = new NativeArray<int>(nc * 3, Allocator.Temp);

                int side = 1, nextCount = 0, activeCount = 0;

                for (int i = 0; i < nc; ++i)
                {
                    TessCell c = cells[i];
                    for (int j = 0; j < 3; ++j)
                    {
                        int x = j, y = (j + 1) % 3;
                        x = (x == 0) ? c.a : (j == 1) ? c.b : c.c;
                        y = (y == 0) ? c.a : (y == 1) ? c.b : c.c;

                        int o = OppositeOf(y, x);
                        int a = m_Neighbors[3 * i + j] = FindNeighbor(cells, count, y, x, o);
                        int b = m_Constraints[3 * i + j] = (-1 != FindConstraint(x, y)) ? 1 : 0;
                        if (a < 0)
                        {
                            if (0 !