uvTotal;
                        uvDist = uvEnd;
                    }

                    column0.uv.y = column1.uv.y = 0;
                    column0.uv.x = column2.uv.x = uvNow;
                    column1.uv.x = column3.uv.x = uvNext;
                    column2.uv.y = column3.uv.y = 1.0f;
                    uvNow = uvNext;
                }

                {
                    // Fix UV and Copy.
                    column0.uv.x = (column0.uv.x * sprInfo.uvInfo.z) + sprInfo.uvInfo.x;
                    column0.uv.y = (column0.uv.y * sprInfo.uvInfo.w) + sprInfo.uvInfo.y;
                    outputVertices[outputVertexCount++] = column0;

                    column1.uv.x = (column1.uv.x * sprInfo.uvInfo.z) + sprInfo.uvInfo.x;
                    column1.uv.y = (column1.uv.y * sprInfo.uvInfo.w) + sprInfo.uvInfo.y;
                    outputVertices[outputVertexCount++] = column1;

                    column2.uv.x = (column2.uv.x * sprInfo.uvInfo.z) + sprInfo.uvInfo.x;
                    column2.uv.y = (column2.uv.y * sprInfo.uvInfo.w) + sprInfo.uvInfo.y;
                    outputVertices[outputVertexCount++] = column2;

                    column3.uv.x = (column3.uv.x * sprInfo.uvInfo.z) + sprInfo.uvInfo.x;
                    column3.uv.y = (column3.uv.y * sprInfo.uvInfo.w) + sprInfo.uvInfo.y;
                    outputVertices[outputVertexCount++] = column3;
                }
            }
            
            //// //// //// //// Stretch             
            if (stretchCorners)
                StretchCorners(segment, outputVertices, outputVertexCount, validHead, validTail, stretcher);
            //// //// //// //// Stretch
 
            outputCount = outputVertexCount;
        }

        bool SkipSegment(JobSegmentInfo isi)
        {
            // Start the Generation.            
            bool skip = (isi.sgInfo.z < 0);
            if (!skip)
            {
                JobSpriteInfo ispr = GetSpriteInfo(isi.sgInfo.z);
                skip = (math.any(ispr.uvInfo) == false);
            }

            if (skip)
            {
                int cis = GetContourIndex(isi.sgInfo.x);
                int cie = GetEndContourIndexOfSegment(isi);
                while (cis < cie)
                {
                    JobContourPoint icp = GetContourPoint(cis);
                    m_ColliderPoints[m_ColliderDataCount++] = icp.position;
                    cis++;
                }
            }

            return skip;
        }

        void TessellateSegments()
        {

            JobControlPoint iscp = GetControlPoint(0);
            bool disableHead = (iscp.cpData.z == kModeContinous && isCarpet);

            float2 zero = new float2(0, 0);
            float2 firstLT = zero;
            float2 firstLB = zero;
            float2 ec = zero;

            for (int i = 0; i < segmentCount; ++i)
            {
                // Tessellate the Segment.
                JobSegmentInfo isi = GetSegmentInfo(i);
                bool skip = SkipSegment(isi);
                if (skip)
                    continue;

                // Internal Data : x, y : pos z : height w : renderIndex
                JobShapeVertex isv = m_VertexData[0];
                JobSpriteInfo ispr = GetSpriteInfo(isi.sgInfo.z);

                int vertexCount = 0;
                int sprIx = isi.sgInfo.z;
                float rpunits = 1.0f / ispr.metaInfo.x;
                float2 whsize = new float2(ispr.metaInfo.z, ispr.metaInfo.w) * rpunits;
                float4 border = ispr.border * rpunits;

                JobControlPoint _scp = GetControlPoint(isi.sgInfo.x);
                JobControlPoint _ecp = GetControlPoint(isi.sgInfo.y);                
                
                bool validHead = hasSpriteBorder && (border.x > 0);
                validHead = validHead && ( _scp.exData.z == 0 || (!isCarpet && i == 0) );
                bool validTail = hasSpriteBorder && (border.z > 0);
                validTail = validTail && ( _ecp.exData.z == 0 || (!isCarpet && i == segmentCount - 1) );

                // Generate the UV Increments.
                float extendUV = 0;
                float stPixelU = border.x;
                float enPixelU = whsize.x - border.z;
                float pxlWidth = enPixelU - stPixelU;
                float segmentD = isi.spriteInfo.w;
                float uIncStep = math.floor(segmentD / pxlWidth);
                uIncStep = uIncStep == 0 ? 1f : uIncStep;
                pxlWidth = isAdaptive ? (segmentD / uIncStep) : pxlWidth;

                // Check for any invalid Sizes.
                if (pxlWidth < kEpsilon)
                {
                    Cleanup();
                    throw new ArgumentException("One of the sprites seem to have Invalid Borders. Please check Input Sprites.");
                }

                // Start the Generation.
                int stIx = GetContourIndex(isi.sgInfo.x);
                int enIx = GetEndContourIndexOfSegment(isi);

                // Single Segment Loop.
                if (stIx == 0)
                    validHead = (validHead && !disableHead);

                // Do we have a Sprite Head Slice
                if (validHead)
                {
                    JobContourPoint icp = GetContourPoint(stIx);
                    float2 v1 = icp.position;
                    float2 v2 = GetContourPoint(stIx + 1).position;
                    isv.pos = v1 + (math.normalize(v1 - v2) * border.x);
                    isv.meta.x = icp.ptData.x;
                    isv.sprite.x = sprIx;
                    m_VertexData[vertexCount++] = isv;
                }

                // Generate the Strip.
                float sl = 0;
                int it = stIx, nt = 0;
                while (it < enIx)
                {
                    nt = it + 1;
                    JobContourPoint icp = GetContourPoint(it);
                    JobContourPoint ncp = GetContourPoint(nt);

                    float2 sp = icp.position;
                    float2 ip = sp;
                    float2 ep = ncp.position;
                    float2 df = ep - sp;
                    float al = math.length(df);
                    if (al > kEpsilon)
                    {
                        float sh = icp.ptData.x, eh = ncp.ptData.x, hl = 0;
                        sl = sl + al;

                        // Connect previously left out space when sl < pxlWidth
                        var addtail = (0 == vertexCount);
                        float2 step = math.normalize(df);
                        isv.pos = icp.position;
                        isv.meta.x = icp.ptData.x;
                        isv.sprite.x = sprIx;

                        if (vertexCount > 0)
                        {
                            var dt = math.length(m_VertexData[vertexCount - 1].pos - isv.pos);
                            addtail = dt > kEpsilonRelaxed;
                        }

                        if (addtail)
                            m_VertexData[vertexCount++] = isv;

                        while (sl > pxlWidth)
                        {
                            float _uv = pxlWidth - extendUV;
                            float2 uv = new float2(_uv);
                            ip = sp + (step * uv);
                            hl = hl + math.length(ip - sp);

                            isv.pos = ip;
                            isv.meta.x = math.lerp(sh, eh, hl / al);
                            isv.sprite.x = sprIx;
                            if (math.any(m_VertexData[vertexCount - 1].pos - isv.pos))
                                m_VertexData[vertexCount++] = isv;

                            sl = sl - pxlWidth;
                            sp = ip;
                            extendUV = 0;
                        }

                        extendUV = sl;
                    }

                    it++;
                }

                // The Remains from the above Loop. Finish the Curve.
                if (sl > kEpsilon)
                {
                    JobContourPoint ecp = GetContourPoint(enIx);
                    isv.pos = ecp.position;
                    isv.meta.x = ecp.ptData.x;
                    isv.sprite.x = sprIx;
                    m_VertexData[vertexCount++] = isv;
                }

                // Generate Tail
                if (validTail)
                {
                    JobContourPoint icp = GetContourPoint(enIx);
                    float2 v1 = icp.position;
                    float2 v2 = GetContourPoint(enIx - 1).position;
                    isv.pos = v1 + (math.normalize(v1 - v2) * border.z);
                    isv.meta.x = icp.ptData.x;
                    isv.sprite.x = sprIx;
                    m_VertexData[vertexCount++] = isv;
                }

                // Generate the Renderer Data.
                int outputCount = 0;
                bool useClosure = (m_ControlPoints[0].cpData.z == kModeContinous) && (isi.sgInfo.y == controlPointCount - 1);
                TessellateSegment(i, ispr, isi, whsize, border, pxlWidth, useClosure, validHead, validTail, m_VertexData, vertexCount, ref m_OutputVertexData, ref outputCount);
                if (outputCount == 0)
                    continue;
                var z = ((float)(i + 1) * kEpsilonOrder) + ((float)isi.sgInfo.z * kEpsilonOrder * 0.001f);
                CopySegmentRenderData(ispr, ref m_PosArray, ref m_Uv0Array, ref m_TanArray, ref m_VertexDataCount, ref m_IndexArray, ref m_IndexDataCount, m_OutputVertexData, outputCount, z);

                if (hasCollider)
                {
                    JobSpriteInfo isprc = (ispr.metaInfo.x == 0) ? GetSpriteInfo(isi.sgInfo.w) : ispr;
                    outputCount = 0;
                    rpunits = 1.0f / isprc.metaInfo.x;
                    whsize = new float2(isprc.metaInfo.z, isprc.metaInfo.w) * rpunits;
                    border = isprc.border * rpunits;
                    stPixelU = border.x;
                    enPixelU = whsize.x - border.z;
                    pxlWidth = enPixelU - stPixelU;
                    TessellateSegment(i, isprc, isi, whsize, border, pxlWidth, useClosure, validHead, validTail, m_VertexData, vertexCount, ref m_OutputVertexData, ref outputCount);
                    ec = UpdateCollider(isi, isprc, m_OutputVertexData, outputCount, ref m_ColliderPoints, ref m_ColliderDataCount);
                }

                // Geom Data
                var geom = m_GeomArray[i + 1];
                geom.geomIndex = i + 1;
                geom.indexCount = m_IndexDataCount - m_ActiveIndexCount;
                geom.vertexCount = m_VertexDataCount - m_ActiveVertexCount;
                geom.spriteIndex = isi.sgInfo.z;
                m_GeomArray[i + 1] = geom;

                // Exit
                m_ActiveIndexCount = m_IndexDataCount;
                m_ActiveVertexCount = m_VertexDataCount;
            }

            // Copy Collider, Copy Render Data.
            m_GeomArrayCount = segmentCount + 1;
            m_IndexArrayCount = m_IndexDataCount;
            m_VertexArrayCount = m_VertexDataCount;
            m_ColliderPointCount = m_ColliderDataCount;
        }

        #endregion

        #region Stretch.
        
        bool FetchStretcher(int segmentIndex, JobSpriteInfo sprInfo, JobSegmentInfo segment, float2 whsize, bool validHead, bool validTail, ref float4 stretcher)
        {
            bool needsStretchL = false, needsStretchR = false;
            int lastSegmentIndex = segmentCount - 1;
            int prevSegmentIndex = segmentIndex == 0 ? lastSegmentIndex : segmentIndex - 1;
            int nextSegmentIndex = segmentIndex == lastSegmentIndex ? 0 : segmentIndex + 1;

            JobSegmentInfo prevSegment = GetSegmentInfo(prevSegmentIndex);
            JobSegmentInfo nextSegment = GetSegmentInfo(nextSegmentIndex);
            JobControlPoint scp = GetControlPoint(segment.sgInfo.x);
            JobControlPoint ecp = GetControlPoint(segment.sgInfo.y);            
            var stretchLeft = (scp.cpData.y == 2) && math.abs(prevSegment.sgInfo.x - prevSegment.sgInfo.y) == 1;
            var stretchRight = (ecp.cpData.y == 2) && math.abs(nextSegment.sgInfo.x - nextSegment.sgInfo.y) == 1;
            var lastControlPoint = (controlPointCount - 1);
            if (!isCarpet)
            {
                stretchLeft = stretchLeft && segment.sgInfo.x != 0;
                stretchRight = stretchRight && segment.sgInfo.y != lastControlPoint;
            }

            if (stretchLeft || stretchRight)
            {
                // Get End points for current segment.
                float2 avlt = float2.zero, avlb = float2.zero, avrt = float2.zero, avrb = float2.zero;
                GetLineSegments(sprInfo, segment, whsize, ref avlt, ref avlb, ref avrt, ref avrb);
                float2 _avlt = avlt, _avlb = avlb, _avrt = avrt, _avrb = avrb;
                float2 ltp = avlt, lbt = avlb, rtp = avrt, rbt = avrb;
                ExtendSegment(ref avlt, ref avrt);
                ExtendSegment(ref avlb, ref avrb);

                // Check Neighbor Next
                if (stretchLeft)
                {

                    if (math.any(m_Intersectors[segment.sgInfo.x].top) && math.any(m_Intersectors[segment.sgInfo.x].bottom))
                    {
                        ltp = m_Intersectors[segment.sgInfo.x].top;
                        lbt = m_Intersectors[segment.sgInfo.x].bottom;
                        needsStretchL = true;
                    }
                    else
                    {
                        // Check end-points match for start and prev.
                        if (1 == scp.exData.z)
                        {
                            // Intersection Test                            
                            float2 pvlt = float2.zero, pvlb = float2.zero, pvrt = float2.zero, pvrb = float2.zero;
                            GetLineSegments(sprInfo, prevSegment, whsize, ref pvlt, ref pvlb, ref pvrt, ref pvrb);
                            ExtendSegment(ref pvlt, ref pvrt);
                            ExtendSegment(ref pvlb, ref pvrb);
                            bool _lt = LineIntersection(kEpsilon, pvlt, pvrt, avlt, avrt, ref ltp);
                            bool _lb = LineIntersection(kEpsilon, pvlb, pvrb, avlb, avrb, ref lbt);
                            needsStretchL = _lt && _lb;
                        }
                        if (needsStretchL)
                        {
                            JobIntersectPoint ip = m_Intersectors[segment.sgInfo.x];
                            ip.top = ltp;
                            ip.bottom = lbt;
                            m_Intersectors[segment.sgInfo.x] = ip;                            
                        }
                    }
                }

                // Check Neighbor Next
                if (stretchRight)
                {

                    if (math.any(m_Intersectors[segment.sgInfo.y].top) && math.any(m_Intersectors[segment.sgInfo.y].bottom))
                    {
                        rtp = m_Intersectors[segment.sgInfo.y].top;
                        rbt = m_Intersectors[segment.sgInfo.y].bottom;
                        needsStretchR = true;
                    }
                    else
                    {
                        // Check end-points match for end and next.
                        if (1 == ecp.exData.z)
                        {
                            // Intersection Test                            
                            float2 nvlt = float2.zero, nvlb = float2.zero, nvrt = float2.zero, nvrb = float2.zero;
                            GetLineSegments(sprInfo, nextSegment, whsize, ref nvlt, ref nvlb, ref nvrt, ref nvrb);
                            ExtendSegment(ref nvlt, ref nvrt);
                            ExtendSegment(ref nvlb, ref nvrb);
                            bool _rt = LineIntersection(kEpsilon, avlt, avrt, nvlt, nvrt, ref rtp);
                            bool _rb = LineIntersection(kEpsilon, avlb, avrb, nvlb, nvrb, ref rbt);
                            needsStretchR = _rt && _rb;
                        }
                        if (needsStretchR)
                        {
                            JobIntersectPoint ip = m_Intersectors[segment.sgInfo.y];
                            ip.top = rtp;
                            ip.bottom = rbt;
                            m_Intersectors[segment.sgInfo.y] = ip;                            
                        }
                    }

                }

                if (needsStretchL || needsStretchR)
                {
                    float2 _lm = (_avlt + _avlb) * 0.5f;
                    float2 _rm = (_avrt + _avrb) * 0.5f;
                    float _m = math.length(_lm - _rm);
                    float _t = math.length(ltp - rtp);
                    float _b = math.length(lbt - rbt);

                    stretcher.x = _t / _m;
                    stretcher.y = _b / _m;
                    stretcher.z = needsStretchL ? 1.0f : 0;
                    stretcher.w = needsStretchR ? 1.0f : 0;
                }
            }

            return (needsStretchL || needsStretchR);
        }

        void StretchCorners(JobSegmentInfo segment, NativeArray<JobShapeVertex> vertices, int vertexCount, bool validHead, bool validTail, float4 stretcher)
        {
            if (vertexCount > 0)
            {
                int lts = validHead ? 4 : 0;
                float2 lt = vertices[lts].pos, _lt = vertices[lts].pos;
                float2 rt = vertices[vertexCount - 3].pos, _rt = vertices[vertexCount - 3].pos;
                float2 lb = vertices[lts + 2].pos, _lb = vertices[lts + 2].pos;
                float2 rb = vertices[vertexCount - 1].pos, _rb = vertices[vertexCount - 1].pos;

                if (math.any(m_Intersectors[segment.sgInfo.x].top) && math.any(m_Intersectors[segment.sgInfo.x].bottom))
                {
                    lt = m_Intersectors[segment.sgInfo.x].top;
                    lb = m_Intersectors[segment.sgInfo.x].bottom;
                }

                if (math.any(m_Intersectors[segment.sgInfo.y].top) && math.any(m_Intersectors[segment.sgInfo.y].bottom))
                {
                    rt = m_Intersectors[segment.sgInfo.y].top;
                    rb = m_Intersectors[segment.sgInfo.y].bottom;
                }
                

                for (int i = lts; i < vertexCount; i = i + 4)
                {
                    JobShapeVertex v0 = vertices[i + 0];
                    JobShapeVertex v1 = vertices[i + 1];
                    JobShapeVertex v2 = vertices[i + 2];
                    JobShapeVertex v3 = vertices[i + 3];

                    v0.pos = lt + ((vertices[i + 0].pos - _lt) * stretcher.x);
                    v1.pos = lt + ((vertices[i + 1].pos - _lt) * stretcher.x);
                    v2.pos = lb + ((vertices[i + 2].pos - _lb) * stretcher.y);
                    v3.pos = lb + ((vertices[i + 3].pos - _lb) * stretcher.y);

                    vertices[i + 0] = v0;
                    vertices[i + 1] = v1;
                    vertices[i + 2] = v2;
                    vertices[i + 3] = v3;
                }

                JobShapeVertex vx = vertices[lts];
                JobShapeVertex vy = vertices[lts + 2];
                vx.pos = lt;
                vy.pos = lb;
                vertices[lts] = vx;
                vertices[lts + 2] = vy;                
                
                JobShapeVertex vz = vertices[vertexCount - 3];
                JobShapeVertex vw = vertices[vertexCount - 1];
                vz.pos = rt;
                vw.pos = rb;
                vertices[vertexCount - 3] = vz;
                vertices[vertexCount - 1] = vw;
            }
        }        
        
        #endregion
        
        #region Corners

        // Extend Segment.
        void ExtendSegment(ref float2 l0, ref float2 r0)
        {
            float2 _l0 = l0, _r0 = r0;
            float2 _x = math.normalize(_r0 - _l0);
            r0 = _r0 + (_x * kExtendSegment);
            l0 = _l0 + (-_x * kExtendSegment);
        }

        bool GetIntersection(int cp, int ct, JobSpriteInfo ispr, ref float2 lt0, ref float2 lb0, ref float2 rt0, ref float2 rb0, ref float2 lt1, ref float2 lb1, ref float2 rt1, ref float2 rb1, ref float2 tp, ref float2 bt)
        {
            // Correct Left.
            float2 zero = new float2(0, 0);
            int pp = (cp == 0) ? (controlPointCount - 1) : (cp - 1);
            int np = (cp + 1) % controlPointCount;
            float pivot = 0.5f - ispr.metaInfo.y;
            
            JobControlPoint lcp = GetControlPoint(pp);
            JobControlPoint ccp = GetControlPoint(cp);
            JobControlPoint rcp = GetControlPoint(np);

            float rpunits = 1.0f / ispr.metaInfo.x;
            float2 whsize = new float2(ispr.texRect.z, ispr.texRect.w) * rpunits;
            float4 border = ispr.border * rpunits;

            // Generate the UV Increments.
            float stPixelV = border.y;
            float enPixelV = whsize.y - border.y;
            float pxlWidth = enPixelV - stPixelV;   // pxlWidth is the square size of the corner sprite.

            // Generate the LeftTop, LeftBottom, RightTop & RightBottom for both sides.
            GenerateColumnsBi(lcp.position, ccp.position, whsize, false, ref lb0, ref lt0, 0.5f, pivot);
            GenerateColumnsBi(ccp.position, lcp.position, whsize, false, ref rt0, ref rb0, 0.5f, pivot);

            GenerateColumnsBi(ccp.position, rcp.position, whsize, false, ref lb1, ref lt1, 0.5f, pivot);
            GenerateColumnsBi(rcp.position, ccp.position, whsize, false, ref rt1, ref rb1, 0.5f, pivot);

            rt0 = rt0 + (math.normalize(rt0 - lt0) * kExtendSegment);
            rb0 = rb0 + (math.normalize(rb0 - lb0) * kExtendSegment);
            lt1 = lt1 + (math.normalize(lt1 - rt1) * kExtendSegment);
            lb1 = lb1 + (math.normalize(lb1 - rb1) * kExtendSegment);

            // Generate Intersection of the Bottom Line Segments.
            bool t = LineIntersection(kEpsilon, lt0, rt0, lt1, rt1, ref tp);
            bool b = LineIntersection(kEpsilon, lb0, rb0, lb1, rb1, ref bt);
            if (!b && !t)
                return false;
            return true;
        }

        bool AttachCorner(int cp, int ct, JobSpriteInfo ispr, ref NativeArray<JobControlPoint> newPoints, ref int activePoint)
        {
            // Correct Left.
            float2 zero = new float2(0, 0);
            float2 tp = zero, bt = zero;
            float2 lt0 = zero, lb0 = zero, rt0 = zero, rb0 = zero, lt1 = zero, lb1 = zero, rt1 = zero, rb1 = zero;            
            float pivot = 0.5f - ispr.metaInfo.y;
            
            int pp = (cp == 0) ? (controlPointCount - 1) : (cp - 1);
            int np = (cp + 1) % controlPointCount;
            
            JobControlPoint lcp = GetControlPoint(pp);
            JobControlPoint ccp = GetControlPoint(cp);
            JobControlPoint rcp = GetControlPoint(np);

            float rpunits = 1.0f / ispr.metaInfo.x;
            float2 whsize = new float2(ispr.texRect.z, ispr.texRect.w) * rpunits;
            float4 border = ispr.border * rpunits;

            // Generate the UV Increments.
            float stPixelV = border.y;
            float enPixelV = whsize.y - border.y;
            float pxlWidth = enPixelV - stPixelV;   // pxlWidth is the square size of the corner sprite.            

            bool intersects = GetIntersection(cp, ct, ispr, ref lt0, ref lb0, ref rt0, ref rb0, ref lt1, ref lb1, ref rt1, ref rb1, ref tp, ref bt);
            if (!intersects)
                return false;
            
            float2 pt = ccp.position;
            float2 lt = lcp.position - pt;
            float2 rt = rcp.position - pt;

            float ld = math.length(lt);
            float rd = math.length(rt);

            if (ld < pxlWidth || rd < pxlWidth)
                return false;

            float lrd = 0, rrd = 0;
            float a = AngleBetweenVector(math.normalize(lcp.position - ccp.position), math.normalize(rcp.position - ccp.position));
            if (a > 0)
            {
                lrd = ld - math.distance(lb0, bt);
                rrd = rd - math.distance(bt, rb1);
            }
            else
            {
                lrd = ld - math.distance(lt0, tp);
                rrd = rd - math.distance(tp, rt1);
            }

            float2 la = pt + (math.normalize(lt) * lrd);
            float2 ra = pt + (math.normalize(rt) * rrd);

            ccp.exData.x = ct;
            ccp.exData.z = 2;    // Start
            ccp.position = la;
            newPoints[activePoint++] = ccp;

            ccp.exData.x = ct;
            ccp.exData.z = 3;    // End
            ccp.position = ra;
            newPoints[activePoint++] = ccp;

            JobCornerInfo iscp = m_Corners[m_CornerCount];
            if (a > 0)
            {
                iscp.bottom = bt;
                iscp.top = tp;
                GenerateColumnsBi(la, lcp.position, whsize, false, ref lt0, ref lb0, ispr.metaInfo.y, pivot);
                GenerateColumnsBi(ra, rcp.position, whsize, false, ref lt1, ref lb1, ispr.metaInfo.y, pivot);
                iscp.left = lt0;
                iscp.right = lb1;
            }
            else
            {
                iscp.bottom = tp;
                iscp.top = bt;
                GenerateColumnsBi(la, lcp.position, whsize, false, ref lt0, ref lb0, ispr.metaInfo.y, pivot);
                GenerateColumnsBi(ra, rcp.position, whsize, false, ref lt1, ref lb1, ispr.metaInfo.y, pivot);
                iscp.left = lb0;
                iscp.right = lt1;
            }
            iscp.cornerData.x = ct;
            iscp.cornerData.y = activePoint;
            m_Corners[m_CornerCount] = iscp;

            m_CornerCount++;
            return true;
        }

        float2 CornerTextureCoordinate(int cornerType, int index)
        {
            int cornerArrayIndex = (cornerType - 1) * 4;
            return m_CornerCoordinates[cornerArrayIndex + index];
        }

        int CalculateCorner(int index, float angle, float2 lt, float2 rt)
        {
            var ct = 0;
            float slope = SlopeAngle(lt);
            var slopePairs = new float2[] 
            {
                new float2(-135.0f, -35.0f),
                new float2(35.0f, 135.0f),
                new float2(-35.0f, 35.0f),
                new float2(-135.0f, 135.0f)
            };
            var cornerPairs = new int2[] 
            {
                new int2(kCornerTypeInnerTopLeft, kCornerTypeOuterBottomLeft),
                new int2(kCornerTypeInnerBottomRight, kCornerTypeOuterTopRight),
                new int2(kCornerTypeInnerTopRight, kCornerTypeOuterTopLeft),
                new int2(kCornerTypeInnerBottomLeft, kCornerTypeOuterBottomRight)
            };
            for (int i = 0; i < 3; ++i)
            {
                if ( slope > slopePairs[i].x && slope < slopePairs[i].y )
                {
                    ct = (angle > 0) ? cornerPairs[i].x : cornerPairs[i].y;
                    break;
                }
            }
            if (ct == 0)
            {
                ct = (angle > 0) ? kCornerTypeInnerBottomLeft : kCornerTypeOuterBottomRight;
            }
            return ct;

        }

        bool InsertCorner(int index, ref NativeArray<int2> cpSpriteIndices, ref NativeArray<JobControlPoint> newPoints, ref int activePoint, ref bool cornerConsidered)
        {
            int i = (index == 0) ? (controlPointCount - 1) : (index - 1);
            int k = (index + 1) % controlPointCount;

            // Check if we have valid Sprites.
            if (cpSpriteIndices[i].x >= spriteCount || cpSpriteIndices[index].x >= spriteCount)
                return false;

            // Check if they have been resolved.
            if (cpSpriteIndices[i].y == 0 || cpSpriteIndices[index].y == 0)
                return false;

            JobControlPoint pcp = GetControlPoint(i);
            JobControlPoint icp = GetControlPoint(index);
            JobControlPoint ncp = GetControlPoint(k);

            // Check if the Mode of control Point and previous neighbor is same. Also check if Corner Toggle is enabled.
            if (icp.cpData.y == 0 || pcp.cpData.z != kModeLinear || icp.cpData.z != kModeLinear || ncp.cpData.z != kModeLinear)
                return false;

            // Check if the Height of the Control Points match
            if (pcp.cpInfo.x != icp.cpInfo.x || icp.cpInfo.x != ncp.cpInfo.x)
                return false;

            JobSpriteInfo psi = GetSpriteInfo(cpSpriteIndices[i].x);
            JobSpriteInfo isi = GetSpriteInfo(cpSpriteIndices[index].x);

            // Check if the Sprites Pivot matches. Otherwise not allowed. // psi.uvInfo.w != isi.uvInfo.w &&  psi.metaInfo.y != 0.5f (no more height and pivot checks)
            if (psi.metaInfo.y != isi.metaInfo.y)
                return false;

            // Now perform expensive stuff like angles etc..
            float2 idir = math.normalize(ncp.position - icp.position);
            float2 ndir = math.normalize(pcp.position - icp.position);
            float angle = AngleBetweenVector(idir, ndir);
            float angleAbs = math.abs(angle);
            cornerConsidered = AngleWithinRange(angleAbs, (90f - m_ShapeParams.curveData.z), (90f + m_ShapeParams.curveData.z)) || (m_ShapeParams.curveData.z == 90.0f);
            if (cornerConsidered && icp.cpData.y == 1)
            {
                float2 rdir = math.normalize(icp.position - pcp.position);
                int ct = CalculateCorner(index, angle, rdir, idir);
                // Check if we have a valid Sprite.
                if (ct > 0)
                {
                    JobSpriteInfo cspr = GetCornerSpriteInfo(ct);
                    return AttachCorner(index, ct, cspr, ref newPoints, ref activePoint);
                }
            }

            return false;
        }

        void TessellateCorners()
        {

            for (int corner = 1; corner <= kCornerTypeInnerBottomRight; ++corner)
            {
                JobSpriteInfo isi = GetCornerSpriteInfo(corner);
                if (isi.metaInfo.x == 0)
                    continue;

                int ic = 0;
                int vc = 0;
                Vector3 pos = m_PosArray[ic];
                Vector2 uv0 = m_Uv0Array[ic];
                bool ccw = (corner <= kCornerTypeOuterBottomRight);
                int vertexArrayCount = m_VertexArrayCount;

                for (int i = 0; i < m_CornerCount; ++i)
                {
                    JobCornerInfo isc = m_Corners[i];
                    if (isc.cornerData.x == corner)
                    {
                        // Vertices.
                        pos.x = isc.top.x;
                        pos.y = isc.top.y;
                        uv0.x = (CornerTextureCoordinate(corner, 1).x * isi.uvInfo.z) + isi.uvInfo.x;
                        uv0.y = (CornerTextureCoordinate(corner, 1).y * isi.uvInfo.w) + isi.uvInfo.y;
                        m_PosArray[m_VertexArrayCount] = pos;
                        m_Uv0Array[m_VertexArrayCount++] = uv0;


                        pos.x = isc.right.x;
                        pos.y = isc.right.y;
                        uv0.x = (CornerTextureCoordinate(corner, 0).x * isi.uvInfo.z) + isi.uvInfo.x;
                        uv0.y = (CornerTextureCoordinate(corner, 0).y * isi.uvInfo.w) + isi.uvInfo.y;
                        m_PosArray[m_VertexArrayCount] = pos;
                        m_Uv0Array[m_VertexArrayCount++] = uv0;

                        pos.x = isc.left.x;
                        pos.y = isc.left.y;
                        uv0.x = (CornerTextureCoordinate(corner, 3).x * isi.uvInfo.z) + isi.uvInfo.x;
                        uv0.y = (CornerTextureCoordinate(corner, 3).y * isi.uvInfo.w) + isi.uvInfo.y;
                        m_PosArray[m_VertexArrayCount] = pos;
                        m_Uv0Array[m_VertexArrayCount++] = uv0;

                        pos.x = isc.bottom.x;
                        pos.y = isc.bottom.y;
                        uv0.x = (CornerTextureCoordinate(corner, 2).x * isi.uvInfo.z) + isi.uvInfo.x;
                        uv0.y = (CornerTextureCoordinate(corner, 2).y * isi.uvInfo.w) + isi.uvInfo.y;
                        m_PosArray[m_VertexArrayCount] = pos;
                        m_Uv0Array[m_VertexArrayCount++] = uv0;

                        // Indices.
                        m_IndexArray[m_IndexArrayCount++] = (ushort)(vc + 0);
                        m_IndexArray[m_IndexArrayCount++] = (ushort)(vc + (ccw ? 1 : 3));
                        m_IndexArray[m_IndexArrayCount++] = (ushort)(vc + (ccw ? 3 : 1));

                        m_IndexArray[m_IndexArrayCount++] = (ushort)(vc + 0);
                        m_IndexArray[m_IndexArrayCount++] = (ushort)(vc + (ccw ? 3 : 2));
                        m_IndexArray[m_IndexArrayCount++] = (ushort)(vc + (ccw ? 2 : 3));

                        vc = vc + 4;
                        ic = ic + 6;
                    }
                }

                if (m_TanArray.Length > 1)
                {
                    for (int i = vertexArrayCount; i < m_VertexArrayCount; ++i)
                        m_TanArray[i] = new Vector4(1.0f, 0, 0, -1.0f);
                }

                // Geom Data
                if (ic > 0 && vc > 0)
                {
                    var geom = m_GeomArray[m_GeomArrayCount];
                    geom.geomIndex = m_GeomArrayCount;
                    geom.indexCount = ic;
                    geom.vertexCount = vc;
                    geom.spriteIndex = m_SpriteInfos.Length + (corner - 1);
                    m_GeomArray[m_GeomArrayCount++] = geom;
                }
            }
        }

        #endregion

        #region Fast Optimizations

        bool AreCollinear(float2 a, float2 b, float2 c, float t)
        {
            float ax = (a.y - b.y) * (a.x - c.x);
            float bx = (a.y - c.y) * (a.x - b.x);
            float aa = math.abs(ax - bx);
            return aa < t;
        }

        // Check if points are co linear and reduce.
        void OptimizePoints(float tolerance, ref NativeArray<float2> pointSet, ref int pointCount)
        {
            int kMinimumPointsRequired = 8;
            if (pointCount < kMinimumPointsRequired)
                return;

            int optimizedColliderPointCount = 0;
            int endColliderPointCount = pointCount - 2;
            bool val = true;
            m_TempPoints[0] = pointSet[0];
            for (int i = 0; i < endColliderPointCount; ++i)
            {
                int j = i;
                float2 v0 = pointSet[i];
                float2 v1 = pointSet[i + 1];
                float2 v2 = pointSet[i + 2];
                val = true;
                while (val && j < endColliderPointCount)
                {
                    val = AreCollinear(v0, v1, v2, tolerance);
                    if (false == val)
                    {
                        m_TempPoints[++optimizedColliderPointCount] = v1;
                        i = j;
                        break;
                    }
                    j++;
                    v1 = pointSet[j + 1];
                    v2 = pointSet[j + 2];
                }
            }
            m_TempPoints[++optimizedColliderPointCount] = pointSet[endColliderPointCount];
            m_TempPoints[++optimizedColliderPointCount] = pointSet[endColliderPointCount + 1];
            if (isCarpet)
                m_TempPoints[++optimizedColliderPointCount] = pointSet[0];
            var localPointCount = optimizedColliderPointCount + 1;

            if (localPointCount > 0)
            {
                pointCount = 0;
                pointSet[pointCount++] = m_TempPoints[0];
                for (int i = 1; i < localPointCount; ++i)
                {
                    if (math.distance(pointSet[pointCount - 1], m_TempPoints[i]) > 0.0001f)
                        pointSet[pointCount++] = m_TempPoints[i];
                }
            }
        }

        #endregion

        #region Collider Specific.
        void AttachCornerToCollider(JobSegmentInfo isi, float pivot, ref NativeArray<float2> colliderPoints, ref int colliderPointCount)
        {
            float2 zero = new float2(0, 0);
            int cornerIndex = isi.sgInfo.x + 1;
            for (int i = 0; i < m_CornerCount; ++i)
            {
                JobCornerInfo isc = m_Corners[i];
                if (cornerIndex == isc.cornerData.y)
                {
                    float2 cp = zero;
                    float2 v0 = zero;
                    if (isc.cornerData.x > kCornerTypeOuterBottomRight)
                        v0 = isc.top;
                    else
                        v0 = isc.bottom;

                    float2 v2 = zero;
                    if (isc.cornerData.x > kCornerTypeOuterBottomRight)
                        v2 = isc.bottom;
                    else
                        v2 = isc.top;
                    cp = (v0 - v2) * pivot;
                    cp = (v2 + cp + v0 + cp) * 0.5f;
                    colliderPoints[colliderPointCount++] = cp;
                    break;
                }
            }
        }

        float2 UpdateCollider(JobSegmentInfo isi, JobSpriteInfo ispr, NativeArray<JobShapeVertex> vertices, int count, ref NativeArray<float2> colliderPoints, ref int colliderPointCount)
        {
            float2 zero = new float2(0, 0);
            float pivot = 0; // 0.5f - ispr.metaInfo.y; // Follow processed geometry and only use ColliderPivot.
            pivot = pivot + colliderPivot;
            AttachCornerToCollider(isi, pivot, ref colliderPoints, ref colliderPointCount);

            float2 cp = zero;
            float2 v0 = zero;
            float2 v2 = zero;

            for (int k = 0; k < count; k = k + 4)
            {
                v0 = vertices[k].pos;
                v2 = vertices[k + 2].pos;
                cp = (v0 - v2) * pivot;
                colliderPoints[colliderPointCount++] = (v2 + cp + v0 + cp) * 0.5f;
            }

            float2 v1 = vertices[count - 1].pos;
            float2 v3 = vertices[count - 3].pos;
            cp = (v3 - v1) * pivot;
            colliderPoints[colliderPointCount++] = (v1 + cp + v3 + cp) * 0.5f;
            return cp;
        }

        void TrimOverlaps()
        {
            int kMinimumPointTolerance = 4;
            if (m_ColliderPointCount < kMinimumPointTolerance)
                return;
            int trimmedPointCount = 0;
            int i = 0;
            int kColliderPointCountClamped = m_ColliderPointCount / 2;
            int kSplineDetailClamped = math.clamp(splineDetail * 3, 0, 8);
            int kNeighbors = kSplineDetailClamped > kColliderPointCountClamped ? kColliderPointCountClamped : kSplineDetailClamped;

            if (!isCarpet)
                m_TempPoints[trimmedPointCount++] = m_ColliderPoints[0];

            while (i < m_ColliderPointCount)
            {
                int h = (i > 0) ? (i - 1) : (m_ColliderPointCount - 1);
                bool noIntersection = true;
                float2 v0 = m_ColliderPoints[h];
                float2 v1 = m_ColliderPoints[i];

                for (int n = kNeighbors; n > 1; --n)
                {
                    int j = (i + n - 1) % m_ColliderPointCount;
                    int k = (i + n) % m_ColliderPointCount;
                    if (k == 0 || i == 0)
                        continue;

                    float2 v2 = m_ColliderPoints[j];
                    float2 v3 = m_ColliderPoints[k];
                    float2 vx = v0 - v3;

                    if (math.abs(math.length(vx)) < kEpsilon)
                        break;

                    float2 vi = v0;

                    bool overLaps = LineIntersection(kEpsilonRelaxed, v0, v1, v2, v3, ref vi);
                    if (overLaps && IsPointOnLines(kEpsilonRelaxed, v0, v1, v2, v3, vi))
                    {
                        noIntersection = false;
                        m_TempPoints[trimmedPointCount++] = vi;
                        i = i + n;
                        break;
                    }
                }

                if (noIntersection)
                {
                    m_TempPoints[trimmedPointCount++] = v1;
                    i = i + 1;
                }
            }
            for (; i < m_ColliderPointCount; ++i)
                m_TempPoints[trimmedPointCount++] = m_ColliderPoints[i];

            i = 0;
            m_ColliderPoints[i++] = m_TempPoints[0];
            float2 prev = m_TempPoints[0];
            for (int j = 1; j < trimmedPointCount; ++j)
            {
                float dist = math.length(m_TempPoints[j] - prev);
                if (dist > kEpsilon)
                    m_ColliderPoints[i++] = m_TempPoints[j];
                prev = m_TempPoints[j];
            }
            trimmedPointCount = i;

            // Check intersection of first line Segment and last.
            float2 vin = m_ColliderPoints[0];
            bool endOverLaps =  LineIntersection(kEpsilonRelaxed, m_ColliderPoints[0], m_ColliderPoints[1], m_ColliderPoints[trimmedPointCount - 1], m_ColliderPoints[trimmedPointCount - 2], ref vin);
            if (endOverLaps && IsPointOnLines(kEpsilonRelaxed, m_ColliderPoints[0], m_ColliderPoints[1], m_ColliderPoints[trimmedPointCount - 1], m_ColliderPoints[trimmedPointCount - 2], vin))
                m_ColliderPoints[0] = vin;
            m_ColliderPointCount = trimmedPointCount;
        }

        void OptimizeCollider()
        {
            if (hasCollider)
            {
                if (kColliderQuality > 0)
                {                    
                    if (kOptimizeCollider > 0)
                    { 
                        OptimizePoints(kColliderQuality, ref m_ColliderPoints, ref m_ColliderPointCount);
                        TrimOverlaps();
                    }
                    m_ColliderPoints[m_ColliderPointCount++] = new float2(0, 0);
                    m_ColliderPoints[m_ColliderPointCount++] = new float2(0, 0);
                }
                if (m_ColliderPointCount <= 2)
                {
                    for (int i = 0; i < m_TessPointCount; ++i)
                        m_ColliderPoints[i] = m_TessPoints[i];
                    m_ColliderPoints[m_TessPointCount] = new float2(0, 0);
                    m_ColliderPoints[m_TessPointCount + 1] = new float2(0, 0);
                    m_ColliderPointCount = m_TessPointCount + 2;
                }
            }
        }

        #endregion

        #region Entry, Exit Points.

        [Obsolete]
        public void Prepare(UnityEngine.U2D.SpriteShapeController controller, SpriteShapeParameters shapeParams, int maxArrayCount, NativeArray<ShapeControlPoint> shapePoints, NativeArray<SpriteShapeMetaData> metaData, AngleRangeInfo[] angleRanges, Sprite[] segmentSprites, Sprite[] cornerSprites)
        {
            // Prepare Inputs.
            PrepareInput(shapeParams, maxArrayCount, shapePoints, controller.optimizeGeometry, controller.autoUpdateCollider, controller.optimizeCollider, controller.colliderOffset, controller.colliderDetail);
            PrepareSprites(segmentSprites, cornerSprites);
            PrepareAngleRanges(angleRanges);
            NativeArray<SplinePointMetaData> newMetaData = new NativeArray<SplinePointMetaData>(metaData.Length, Allocator.Temp);
            for (int i = 0; i < metaData.Length; ++i)
            {
                SplinePointMetaData newData = new SplinePointMetaData();
                newData.height = metaData[i].height;
                newData.spriteIndex = metaData[i].spriteIndex;
                newData.cornerMode = metaData[i].corner ? (int)Corner.Automatic : (int)Corner.Disable;
                newMetaData[i] = newData;
            }
            PrepareControlPoints(shapePoints, newMetaData);
            newMetaData.Dispose();

            // Generate Fill. Obsolete API and let's stick with main-thread fill.
            kModeUTess = 0;            
            TessellateContourMainThread();
        }

        internal void Prepare(UnityEngine.U2D.SpriteShapeController controller, SpriteShapeParameters shapeParams, int maxArrayCount, NativeArray<ShapeControlPoint> shapePoints, NativeArray<SplinePointMetaData> metaData, AngleRangeInfo[] angleRanges, Sprite[] segmentSprites, Sprite[] cornerSprites, bool UseUTess)
        {
            // Prepare Inputs.
            PrepareInput(shapeParams, maxArrayCount, shapePoints, controller.optimizeGeometry, controller.autoUpdateCollider, controller.optimizeCollider, controller.colliderOffset, controller.colliderDetail);
            PrepareSprites(segmentSprites, cornerSprites);
            PrepareAngleRanges(angleRanges);
            PrepareControlPoints(shapePoints, metaData);

            // Generate Fill.
            kModeUTess = UseUTess ? 1 : 0;
            if (0 == kModeUTess)
                TessellateContourMainThread();
        }        
        
        public void Execute()
        {
            // BURST
            if (0 != kModeUTess)
                TessellateContour();
            GenerateSegments();
            UpdateSegments();
            TessellateSegments();
            TessellateCorners();
            CalculateBoundingBox();
            CalculateTexCoords();
            OptimizeCollider();
        }

        // Only needed if Burst is disabled.
        // [BurstDiscard]
        public void Cleanup()
        {
            SafeDispose(m_Corners);
            SafeDispose(m_CornerSpriteInfos);
            SafeDispose(m_SpriteInfos);
            SafeDispose(m_AngleRanges);
            SafeDispose(m_Segments);
            SafeDispose(m_ControlPoints);
            SafeDispose(m_ContourPoints);
            SafeDispose(m_TempPoints);
            SafeDispose(m_GeneratedControlPoints);
            SafeDispose(m_SpriteIndices);
            SafeDispose(m_Intersectors);
            
            SafeDispose(m_TessPoints);
            SafeDispose(m_VertexData);
            SafeDispose(m_OutputVertexData);
            SafeDispose(m_CornerCoordinates);
        }

        #endregion

    }
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     using System;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.U2D;
using Unity.Collections;

[Serializable]
internal struct SpriteShapeGeometryInfo
{
    [SerializeField]
    internal int geomIndex;
    [SerializeField]
    internal int indexCount;
    [SerializeField]
    internal int vertexCount;
    [SerializeField]
    internal int spriteIndex;
}

// Simple Cache for SpriteShape Geometry Data.
[AddComponentMenu("")]
internal class SpriteShapeGeometryCache : MonoBehaviour
{

    // Serialized Data.
    [SerializeField]
    [HideInInspector]
    int m_MaxArrayCount;
    [SerializeField]
    [HideInInspector]
    Vector3[] m_PosArray = null;
    [SerializeField]
    [HideInInspector]
    Vector2[] m_Uv0Array = null;
    [SerializeField]
    [HideInInspector]
    Vector4[] m_TanArray = null;
    [SerializeField]
    [HideInInspector]
    ushort[] m_IndexArray = null;
    [SerializeField]
    [HideInInspector]
    SpriteShapeGeometryInfo[] m_GeomArray = null;

    // Update set.
    bool m_RequiresUpdate = false;
    bool m_RequiresUpload = false;
    NativeSlice<Vector3> m_PosArrayCache;
    NativeSlice<Vector2> m_Uv0ArrayCache;
    NativeSlice<Vector4> m_TanArrayCache;
    NativeArray<ushort> m_IndexArrayCache;
    NativeArray<UnityEngine.U2D.SpriteShapeSegment> m_GeomArrayCache;

    internal int maxArrayCount
    {
        get { return m_MaxArrayCount; }
    }

    void OnEnable()
    {
        m_RequiresUpload = true;
        m_RequiresUpdate = false;
    }

    // Set Geometry Cache.
    internal void SetGeometryCache(int _maxArrayCount, NativeSlice<Vector3> _posArray, NativeSlice<Vector2> _uv0Array, NativeSlice<Vector4> _tanArray, NativeArray<ushort> _indexArray, NativeArray<UnityEngine.U2D.SpriteShapeSegment> _geomArray)
    {
        m_RequiresUpdate = true;
        m_PosArrayCache = _posArray;
        m_Uv0ArrayCache = _uv0Array;
        m_TanArrayCache = _tanArray;
        m_GeomArrayCache = _geomArray;
        m_IndexArrayCache = _indexArray;
        m_MaxArrayCount = _maxArrayCount;
    }

    // Update GeometryCache.
    internal void UpdateGeometryCache()
    {
        bool updateCache = m_RequiresUpdate && m_GeomArrayCache.IsCreated;
        updateCache = updateCache && m_IndexArrayCache.IsCreated;
        if (updateCache)
        {
            int geomCount = 0;
            int indexCount = 0;
            int vertexCount = 0;

            for (int i = 0; (i < m_GeomArrayCache.Length); ++i)
            {
                var geom = m_GeomArrayCache[i];
                indexCount += geom.indexCount;
                vertexCount += geom.vertexCount;
                if (geom.vertexCount > 0)
                    geomCount = i + 1;
            }

            m_GeomArray = new SpriteShapeGeometryInfo[geomCount];
            NativeArray<SpriteShapeGeometryInfo> geomInfoArray = m_GeomArrayCache.Reinterpret<SpriteShapeGeometryInfo>();
            SpriteShapeCopyUtility<SpriteShapeGeometryInfo>.Copy(m_GeomArray, geomInfoArray, geomCount);

            m_PosArray = new Vector3[vertexCount];
            m_Uv0Array = new Vector2[vertexCount];
            m_TanArray = new Vector4[vertexCount];
            m_IndexArray = new ushort[indexCount];

            SpriteShapeCopyUtility<Vector3>.Copy(m_PosArray, m_PosArrayCache, vertexCount);
            SpriteShapeCopyUtility<Vector2>.Copy(m_Uv0Array, m_Uv0ArrayCache, vertexCount);
            SpriteShapeCopyUtility<Vector4>.Copy(m_TanArray, m_TanArrayCache, vertexCount);
            SpriteShapeCopyUtility<ushort>.Copy(m_IndexArray, m_IndexArrayCache, indexCount);

            m_MaxArrayCount = (vertexCount > indexCount) ? vertexCount : indexCount;
            m_RequiresUpdate = false;
        }
    }

    internal JobHandle Upload(SpriteShapeRenderer sr, SpriteShapeController sc)
    {

        JobHandle jobHandle = (default);
        if (m_RequiresUpload)
        {

            // Update Geometries.
            NativeArray<SpriteShapeSegment> geomArray = sr.GetSegments(m_GeomArray.Length);
            NativeArray<SpriteShapeGeometryInfo> geomInfoArray = geomArray.Reinterpret<SpriteShapeGeometryInfo>();
            geomInfoArray.CopyFrom(m_GeomArray);

            // Update Mesh Data.
            NativeSlice<Vector3> posArray;
            NativeSlice<Vector2> uv0Array;
            NativeArray<ushort> indexArray;

            if (sc.enableTangents)
            {
                NativeSlice<Vector4> tanArray;
                sr.GetChannels(m_MaxArrayCount, out indexArray, out posArray, out uv0Array, out tanArray);
                SpriteShapeCopyUtility<Vector4>.Copy(tanArray, m_TanArray, m_TanArray.Length);
            }
            else
            {
                sr.GetChannels(m_MaxArrayCount, out indexArray, out posArray, out uv0Array);
            }

            SpriteShapeCopyUtility<Vector3>.Copy(posArray, m_PosArray, m_PosArray.Length);
            SpriteShapeCopyUtility<Vector2>.Copy(uv0Array, m_Uv0Array, m_Uv0Array.Length);
            SpriteShapeCopyUtility<ushort>.Copy(indexArray, m_IndexArray, m_IndexArray.Length);
            sr.Prepare(jobHandle, sc.spriteShapeParameters, sc.spriteArray);
            m_RequiresUpload = false;

        }
        return jobHandle;

    }

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace UnityEngine.U2D
{

    namespace UTess
    {

        [StructLayout(LayoutKind.Sequential)]
        [DebuggerDisplay("Length = {Length}")]
        internal unsafe struct ArraySlice<T> : System.IEquatable<ArraySlice<T>> where T : struct
        {
            [NativeDisableUnsafePtrRestriction] internal byte* m_Buffer;
            internal int m_Stride;
            internal int m_Length;
            
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            internal int m_MinIndex;
            internal int m_MaxIndex;
            internal AtomicSafetyHandle m_Safety;
#endif

            public ArraySlice(NativeArray<T> array, int start, int length)
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                if (start < 0)
                    throw new ArgumentOutOfRangeException(nameof(start), $"Slice start {start} < 0.");
                if (length < 0)
                    throw new ArgumentOutOfRangeException(nameof(length), $"Slice length {length} < 0.");
                if (start + length > array.Length)
                    throw new ArgumentException(
                        $"Slice start + length ({start + length}) range must be <= array.Length ({array.Length})");
                m_MinIndex = 0;
                m_MaxIndex = length - 1;
                m_Safety = Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility.GetAtomicSafetyHandle(array);
#endif

                m_Stride = UnsafeUtility.SizeOf<T>();
                var ptr = (byte*) array.GetUnsafePtr() + m_Stride * start;
                m_Buffer = ptr;
                m_Length = length;
            }

            public bool Equals(ArraySlice<T> other)
            {
                return m_Buffer == other.m_Buffer && m_Stride == other.m_Stride && m_Length == other.m_Length;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                return obj is ArraySlice<T> && Equals((ArraySlice<T>) obj);
            }

            public override int GetHashCode()
            {
                unchecked
                {
                    var hashCode = (int) m_Buffer;
                    hashCode = (hashCode * 397) ^ m_Stride;
                    hashCode = (hashCode * 397) ^ m_Length;
                    return hashCode;
                }
            }

            public static bool operator ==(ArraySlice<T> left, ArraySlice<T> right)
            {
                return left.Equals(right);
            }

            public static bool operator !=(ArraySlice<T> left, ArraySlice<T> right)
            {
                return !left.Equals(right);
            }

#if ENABLE_UNITY_COLLECTIONS_CHECKS
            // These are double-whammy excluded to we can elide bounds checks in the Burst disassembly view
            [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
            void CheckReadIndex(int index)
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                if (index < m_MinIndex || index > m_MaxIndex)
                    FailOutOfRangeError(index);
#endif
            }

            [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
            void CheckWriteIndex(int index)
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                if (index < m_MinIndex || index > m_MaxIndex)
                    FailOutOfRangeError(index);
#endif
            }

            [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
            private void FailOutOfRangeError(int index)
            {
                if (index < Length && (m_MinIndex != 0 || m_MaxIndex != Length - 1))
                    throw new System.IndexOutOfRangeException(
                        $"Index {index} is out of restricted IJobParallelFor range [{m_MinIndex}...{m_MaxIndex}] in ReadWriteBuffer.\n" +
                        "ReadWriteBuffers are restricted to only read & write the element at the job index. " +
                        "You can use double buffering strategies to avoid race conditions due to " +
                        "reading & writing in parallel to the same elements from a job.");

                throw new System.IndexOutOfRangeException($"Index {index} is out of range of '{Length}' Length.");
            }

#endif

            public static unsafe ArraySlice<T> ConvertExistingDataToArraySlice(void* dataPointer, int stride, int length)
            {
                if (length < 0)
                    throw new System.ArgumentException($"Invalid length of '{length}'. It must be greater than 0.",
                        nameof(length));
                if (stride < 0)
                    throw new System.ArgumentException($"Invalid stride '{stride}'. It must be greater than 0.",
                        nameof(stride));

                var newSlice = new ArraySlice<T>
                {
                    m_Stride = stride,
                    m_Buffer = (byte*) dataPointer,
                    m_Length = length,
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    m_MinIndex = 0,
                    m_MaxIndex = length - 1,
#endif
                };

                return newSlice;
            }

            public T this[int index]
            {
                get
                {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    CheckReadIndex(index);
#endif
                    return UnsafeUtility.ReadArrayElementWithStride<T>(m_Buffer, index, m_Stride);
                }

                [WriteAccessRequired]
                set
                {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    CheckWriteIndex(index);
#endif
                    UnsafeUtility.WriteArrayElementWithStride(m_Buffer, index, m_Stride, value);
                }
            }

            public int Stride => m_Stride;
            public int Length => m_Length;

        }
        
    }

}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ﻿using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Mathematics;
using Unity.Collections.LowLevel.Unsafe;

namespace UnityEngine.U2D
{

    namespace UTess
    {

        enum TessEventType
        {
            EVENT_POINT = 0,
            EVENT_END = 1,
            EVENT_START = 2,
        };

        struct TessEdge
        {
            public int a;
            public int b;
        };

        struct TessEvent
        {
            public float2 a;
            public float2 b;
            public int idx;
            public int type;
        };

        struct TessHull
        {
            public float2 a;
            public float2 b;
            public int idx;

            public ArraySlice<int> ilarray;
            public int ilcount;
            public ArraySlice<int> iuarray;
            public int iucount;
        };

        struct TessCell
        {
            public int a;
            public int b;
            public int c;
        };

        struct TessStar
        {
            public ArraySlice<int> points;
            public int pointCount;
        };

        internal struct TessUtils
        {

            // From https://www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c and is public domain. Can't find one within Unity.
            public static float OrientFast(float2 a, float2 b, float2 c)
            {
                float epsilon = 1.1102230246251565e-16f;
                float errbound3 = (3.0f + 16.0f * epsilon) * epsilon;
                float l = (a.y - c.y) * (b.x - c.x);
                float r = (a.x - c.x) * (b.y - c.y);
                float det = l - r;
                float s = 0;
                if (l > 0)
                {
                    if (r <= 0)
                    {
                        return det;
                    }
                    else
                    {
                        s = l + r;
                    }
                }
                else if (l < 0)
                {
                    if (r >= 0)
                    {
                        return det;
                    }
                    else
                    {
                        s = -(l + r);
                    }
                }
                else
                {
                    return det;
                }

                float tol = errbound3 * s;
                if (det >= tol || det <= -tol)
                {
                    return det;
                }

                return epsilon;
            }

            public static float Norm(float2 cV)
            {
                return cV.x * cV.x + cV.y * cV.y;
            }

            public static float Dist(float2 cV1, float2 cV2)
            {
                return (cV1.x - cV2.x) * (cV1.x - cV2.x) + (cV1.y - cV2.y) * (cV1.y - cV2.y);
            }            
            public static bool IsInsideCircle(float2 a, float2 b, float2 c, float2 p)
            {
                float ab = Norm(a);
                float cd = Norm(b);
                float ef = Norm(c);

                float ax = a.x;
                float ay = a.y;
                float bx = b.x;
                float by = b.y;
                float cx = c.x;
                float cy = c.y;

                float circum_x = (ab * (cy - by) + cd * (ay - cy) + ef * (by - ay)) /
                                 (ax * (cy - by) + bx * (ay - cy) + cx * (by - ay));
                float circum_y = (ab * (cx - bx) + cd * (ax - cx) + ef * (bx - ax)) /
                                 (ay * (cx - bx) + by * (ax - cx) + cy * (bx - ax));

                float2 circum = new float2();
                circum.x = circum_x / 2;
                circum.y = circum_y / 2;
                float circum_radius = Dist(a, circum);
                float dist = Dist(p, circum);
                return circum_radius - dist > 0.00001f;
            }

            public unsafe static void InsertionSort<T, U>(void* array, int lo, int hi, U comp)
                where T : struct where U : IComparer<T>
            {
                int i, j;
                T t;
                for (i = lo; i < hi; i++)
                {
                    j = i;
                    t = UnsafeUtility.ReadArrayElement<T>(array, i + 1);
                    while (j >= lo && comp.Compare(t, UnsafeUtility.ReadArrayElement<T>(array, j)) < 0)
                    {
                        UnsafeUtility.WriteArrayElement<T>(array, j + 1, UnsafeUtility.ReadArrayElement<T>(array, j));
                        j--;
                    }

                    UnsafeUtility.WriteArrayElement<T>(array, j + 1, t);
                }
            }

        }

        struct TessEventCompare : IComparer<TessEvent>
        {
            public int Compare(TessEvent a, TessEvent b)
            {
                float f = (a.a.x - b.a.x);
                if (0 != f)
                    return (f > 0) ? 1 : -1;

                f = (a.a.y - b.a.y);
                if (0 != f)
                    return (f > 0) ? 1 : -1;

                int i = a.type - b.type;
                if (0 != i)
                    return i;

                if (a.type != (int) TessEventType.EVENT_POINT)
                {
                    float o = TessUtils.OrientFast(a.a, a.b, b.b);
                    if (0 != o)
                    {
                        return (o > 0) ? 1 : -1;
                    }
                }

                return a.idx - b.idx;
            }
        }

        struct TessEdgeCompare : IComparer<TessEdge>
        {
            public int Compare(TessEdge a, TessEdge b)
            {
                int i = a.a - b.a;
                if (0 != i)
                    return i;
                i = a.b - b.b;
                return i;
            }
        }

        struct TessCellCompare : IComparer<TessCell>
        {
            public int Compare(TessCell a, TessCell b)
            {
                int i = a.a - b.a;
                if (0 != i)
                    return i;
                i = a.b - b.b;
                if (0 != i)
                    return i;
                i = a.c - b.c;
                return i;
            }
        }

        internal struct Tessellator
        {
            // For Processing.
            NativeArray<TessEdge> m_Edges;
            NativeArray<TessStar> m_Stars;
            NativeArray<TessCell> m_Cells;
            int m_CellCount;

            // For Storage.
            NativeArray<int> m_ILArray;
            NativeArray<int> m_IUArray;
            NativeArray<int> m_SPArray;
            int m_NumPoints;
            int m_StarCount;            

            // Intermediates.
            NativeArray<int> m_Flags;
            NativeArray<int> m_Neighbors;
            NativeArray<int> m_Constraints;

            static float TestPoint(TessHull hull, float2 point)
            {
                return TessUtils.OrientFast(hull.a, hull.b, point);
            }

            static int GetLowerHullForVector(NativeArray<TessHull> hulls, int hullCount, float2 p)
            {
                int i;
                int l = 0;
                int h = hullCount - 1;
                i = l - 1;
                while (l <= h)
                {
                    int m;
                    m = ((int) (l + h)) >> 1;
                    if (TestPoint(hulls[m], p) < 0)
                    {
                        i = m;
                        l = m + 1;
                    }
                    else
                        h = m - 1;
                }

                return i;
            }

            static int GetUpperHullForVector(NativeArray<TessHull> hulls, int hullCount, float2 p)
            {
                int i;
                int l = 0;
                int h = hullCount - 1;
                i = h + 1;
                while (l <= h)
                {
                    int m;
                    m = ((int) (l + h)) >> 1;
                    if (TestPoint(hulls[m], p) > 0)
                    {
                        i = m;
                        h = m - 1;
                    }
                    else
                        l = m + 1;
                }

                return i;
            }

            static float FindSplit(TessHull hull, TessEvent edge)
            {
                float d = 0;
                if (hull.a.x < edge.a.x)
                {
                    d = TessUtils.OrientFast(hull.a, hull.b, edge.a);
                }
                else
                {
                    d = TessUtils.OrientFast(edge.b, edge.a, hull.a);
                }

                if (0 != d)
                {
                    return d;
                }

                if (edge.b.x < hull.b.x)
                {
                    d = TessUtils.OrientFast(hull.a, hull.b, edge.b);
                }
                else
                {
                    d = TessUtils.OrientFast(edge.b, edge.a, hull.b);
                }

                if (0 != d)
                {
                    return d;
                }

                return hull.idx - edge.idx;
            }

            static int GetLowerEqualHullForEvent(NativeArray<TessHull> hulls, int hullCount, TessEvent p)
            {
                int i;
                int l = 0;
                int h = hullCount - 1;
                i = l - 1;
                while (l <= h)
                {
                    int m;
                    m = ((int) (l + h)) >> 1;
                    if (FindSplit(hulls[m], p) <= 0)
                    {
                        i = m;
                        l = m + 1;
                    }
                    else
                        h = m - 1;
                }

                return i;
            }

            static int GetEqualHullForEvent(NativeArray<TessHull> hulls, int hullCount, TessEvent p)
            {
                int l = 0;
                int h = hullCount - 1;
                while (l <= h)
                {
                    int m;
                    m = ((int) (l + h)) >> 1;
                    float f = FindSplit(hulls[m], p);
                    if (f == 0)
                    {
                        return m;
                    }
                    else if (f <= 0)
                    {
                        l = m + 1;
                    }
                    else
                        h = m - 1;
                }

                return -1;
            }

            void AddPoint(NativeArray<TessHull> hulls, int hullCount, NativeArray<float2> points, float2 p,
                int idx)
            {
                int l = GetLowerHullForVector(hulls, hullCount, p);
                int u = GetUpperHullForVector(hulls, hullCount, p);
                for (int i = l; i < u; ++i)
                {
                    TessHull hull = hulls[i];

                    int m = hull.ilcount;
                    while (m > 1 && TessUtils.OrientFast(points[hull.ilarray[m - 2]], points[hull.ilarray[m - 1]], p) >
                        0)
                    {
                        TessCell c = new TessCell();
                        c.a = hull.ilarray[m - 1];
                        c.b = hull.ilarray[m - 2];
                        c.c = idx;
                        m_Cells[m_CellCount++] = c;
                        m -= 1;
                    }

                    hull.ilcount = m + 1;
                    hull.ilarray[m] = idx;

                    m = hull.iucount;
                    while (m > 1 && TessUtils.OrientFast(points[hull.iuarray[m - 2]], points[hull.iuarray[m - 1]], p) <
                        0)
                    {
                        TessCell c = new TessCell();
                        c.a = hull.iuarray[m - 2];
                        c.b = hull.iuarray[m - 1];
                        c.c = idx;
                        m_Cells[m_CellCount++] = c;
                        m -= 1;
                    }

                    hull.iucount = m + 1;
                    hull.iuarray[m] = idx;

                    hulls[i] = hull;
                }
            }

            static void InsertHull(NativeArray<TessHull> Hulls, int Pos, ref int Count, TessHull Value)
            {
                if (Count < Hulls.Length - 1)
                {
                    for (int i = Count; i > Pos; --i)
                        Hulls[i] = Hulls[i - 1];
                    Hulls[Pos] = Value;
                    Count++;
                }
            }

            static void EraseHull(NativeArray<TessHull> Hulls, int Pos, ref int Count)
            {
                if (Count < Hulls.Length)
                {
                    for (int i = Pos; i < Count - 1; ++i)
                        Hulls[i] = Hulls[i + 1];
                    Count--;
                }
            }

            void SplitHulls(NativeArray<TessHull> hulls, ref int hullCount, NativeArray<float2> points,
                TessEvent evt)
            {
                int index = GetLowerEqualHullForEvent(hulls, hullCount, evt);
                TessHull hull = hulls[index];

                TessHull newHull;
                newHull.a = evt.a;
                newHull.b = evt.b;
                newHull.idx = evt.idx;

                int y = hull.iuarray[hull.iucount - 1];
                newHull.iuarray = new ArraySlice<int>(m_IUArray, newHull.idx * m_NumPoints, m_NumPoints);
                newHull.iucount = hull.iucount;
                for (int i = 0; i < newHull.iucount; ++i)
                    newHull.iuarray[i] = hull.iuarray[i];
                hull.iuarray[0] = y;
                hull.iucount = 1;
                hulls[index] = hull;

                newHull.ilarray = new ArraySlice<int>(m_ILArray, newHull.idx * m_NumPoints, m_NumPoints);
                newHull.ilarray[0] = y;
                newHull.ilcount = 1;

                InsertHull(hulls, index + 1, ref hullCount, newHull);
            }

            void MergeHulls(NativeArray<TessHull> hulls, ref int hullCount, NativeArray<float2> points,
                TessEvent evt)
            {
                float2 temp = evt.a;
                evt.a = evt.b;
                evt.b = temp;
                int index = GetEqualHullForEvent(hulls, hullCount, evt);

                TessHull upper = hulls[index];
                TessHull lower = hulls[index - 1];

                lower.iucount = upper.iucount;
                for (int i = 0; i < lower.iucount; ++i)
                    lower.iuarray[i] = upper.iuarray[i];

                hulls[index - 1] = lower;
                EraseHull(hulls, index, ref hullCount);
            }

            internal void Triangulate(NativeArray<float2> points, NativeArray<TessEdge> edgesIn)
            {
                int numEdges = edgesIn.Length;
                const int kStarEdges = 16;

                m_NumPoints = points.Length;
                m_StarCount = m_NumPoints > kStarEdges ? m_NumPoints : kStarEdges;
                m_StarCount = m_StarCount * 2;
                m_CellCount = 0;
                m_Cells = new NativeArray<TessCell>(m_NumPoints * (m_NumPoints + 1), Allocator.Temp);
                m_ILArray = new NativeArray<int>(m_NumPoints * (m_NumPoints + 1), Allocator.Temp); // Make room for -1 node.
                m_IUArray = new NativeArray<int>(m_NumPoints * (m_NumPoints + 1), Allocator.Temp); // Make room for -1 node.
                m_SPArray = new NativeArray<int>(m_NumPoints * (m_StarCount), Allocator.Temp); // Make room for -1 node.

                NativeArray<TessHull> hulls = new NativeArray<TessHull>(m_NumPoints * 8, Allocator.Temp);
                int hullCount = 0;

                NativeArray<TessEvent> events = new NativeArr